# backend/tools/server_parser.py

import os
import re
import yaml
import tomli
import tomli_w
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap
from typing import Dict, Any, Tuple, Optional
from pathlib import Path

from backend.core.utils import get_fabric_jar_version, get_forge_jar_version, get_vanilla_jar_version, get_velocity_jar_version
from backend.core.logger import logger
from backend.core.schemas import ServerType
from backend.core import models, schemas


def parse_velocity_toml(file_path: Path) -> Dict[str, Any]:
    if not file_path.exists():
        return {}
    forwarding_secret_path = file_path.parent / "forwarding.secret"
    forwarding_secret = None
    if forwarding_secret_path.exists():
        with open(forwarding_secret_path, "r", encoding='utf-8') as f:
            forwarding_secret = f.read()
    with open(file_path, "rb") as f:
        try:
            data = tomli.load(f)
            servers_config = data.get("servers", {})
            try_order = servers_config.pop("try", [])

            return {
                "bind": data.get("bind", "0.0.0.0:25565"),
                "motd": data.get("motd", ""),
                "online-mode": data.get("online-mode", True),
                "player-info-forwarding-mode": data.get("player-info-forwarding-mode", "none"),
                "servers": servers_config,
                "try": try_order,
                "forwarding_secret": forwarding_secret
            }
        except tomli.TOMLDecodeError:
            return {}


def write_velocity_toml(file_path: Path, config: Dict[str, Any]):
    try:
        with open(file_path, "rb") as f:
            toml_data = tomli.load(f)
    except (FileNotFoundError, tomli.TOMLDecodeError):
        toml_data = {}
    forwarding_secret_path = file_path.parent / "forwarding.secret"
    toml_data['bind'] = config.get('bind', toml_data.get('bind', '0.0.0.0:25565'))
    toml_data['motd'] = config.get('motd', toml_data.get('motd', '<#09add3>A Velocity Server'))
    toml_data['online-mode'] = config.get('online-mode', toml_data.get('online-mode', True))
    toml_data['player-info-forwarding-mode'] = config.get(
        'player-info-forwarding-mode', toml_data.get('player-info-forwarding-mode', 'none')
    )
    if 'servers' not in toml_data or not isinstance(toml_data.get('servers'), dict):
        toml_data['servers'] = {}
    new_servers = config.get('servers', {})
    new_try_order = config.get('try', [])
    current_server_keys = list(parse_velocity_toml(file_path).get('servers', {}).keys())
    for key in current_server_keys:
        if key in toml_data['servers']:
            del toml_data['servers'][key]
    toml_data['servers'].update(new_servers)
    toml_data['servers']['try'] = new_try_order
    toml_data['forced-hosts'] = {}
    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "wb") as f:
        tomli_w.dump(toml_data, f)
    if (secret := config.get("forwarding_secret", None)) is not None:
        with open(forwarding_secret_path, "w", encoding='utf-8') as f:
            f.write(str(secret))


def parse_properties(file_path):
    """解析 Java .properties 文件"""
    props = {}
    if not os.path.exists(file_path):
        return props
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    key_value = line.split('=', 1)
                    if len(key_value) == 2:
                        value = key_value[1].strip()
                        props[key_value[0].strip()] = key_value[1].strip()
                        if value.lower() == 'true':
                            value = True
                        elif value.lower() == 'false':
                            value = False
                        elif value.isdigit():
                            value = int(value)
                        props[key_value[0].strip()] = value
    except Exception:
        # 文件可能存在编码问题等，忽略错误
        pass
    return props


def write_properties_file(path: Path, props: Dict[str, Any]):
    """将字典写入 .properties 文件"""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write("# Minecraft server properties\n")
        f.write("# Generated by AS-Panel\n")
        for key, value in props.items():
            f.write(f"{key}={str(value).lower() if isinstance(value, bool) else value}\n")


def parse_jvm_args(args_str: str) -> schemas.ServerConfigJvm:
    """从 jvm_args 字符串中解析出内存和额外参数"""
    min_mem_match = re.search(r'-Xms(\S+)', args_str)
    max_mem_match = re.search(r'-Xmx(\S+)', args_str)

    min_mem = min_mem_match.group(1) if min_mem_match else "1G"
    max_mem = max_mem_match.group(1) if max_mem_match else "4G"
    # 移除内存参数以获取额外参数
    extra_args = args_str.replace(min_mem_match.group(0), '') if min_mem_match else args_str
    extra_args = extra_args.replace(max_mem_match.group(0), '') if max_mem_match else extra_args

    return schemas.ServerConfigJvm(
        min_memory=min_mem,
        max_memory=max_mem,
        extra_args=extra_args.strip()
    )


def parse_start_command(command_str: str) -> Tuple[schemas.ServerConfigJvm, str]:
    if not command_str:
        return schemas.ServerConfigJvm(java_command=None, min_memory="1G", max_memory="4G", extra_args=""), "server.jar"
    parts = command_str.split()
    java_cmd = parts[0] if parts else None
    try:
        jar_index = parts.index('-jar')
        jar_name = parts[jar_index + 1]
        jvm_args_list = parts[1:jar_index]
        jvm_config = parse_jvm_args(' '.join(jvm_args_list))
        jvm_config.java_command = java_cmd
        return jvm_config, jar_name
    except (ValueError, IndexError):
        jvm_config = parse_jvm_args(' '.join(parts[1:]))
        jvm_config.java_command = java_cmd
        return jvm_config, "server.jar"


def parse_mcdr_config(file_path: Path) -> Dict:
    with file_path.open('r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    return config if isinstance(config, dict) else {}


def _deep_update(source: Dict, overrides: Dict) -> Dict:
    for key, value in overrides.items():
        if isinstance(value, dict) and key in source and isinstance(source.get(key), dict):
            source[key] = _deep_update(source[key], value)
        else:
            source[key] = value
    return source


def _convert_to_dict(data: Any) -> Any:
    if isinstance(data, CommentedMap):
        return {key: _convert_to_dict(value) for key, value in data.items()}
    if isinstance(data, list):
        return [_convert_to_dict(element) for element in data]
    return data


def write_mcdr_config(file_path: Path, config: Dict) -> Dict:
    yaml_rt = YAML()
    yaml_rt.indent(mapping=2, sequence=4, offset=2)
    yaml_rt.preserve_quotes = True
    if file_path.is_file():
        with file_path.open('r', encoding='utf-8') as f:
            data = yaml_rt.load(f)
    else:
        data = CommentedMap()
    updated_data = _deep_update(data, config)
    with file_path.open('w', encoding='utf-8') as f:
        yaml_rt.dump(updated_data, f)
    return _convert_to_dict(updated_data)


def parse_fabric_launch_properties(props_path: Path) -> Optional[str]:
    if not props_path.is_file():
        return None
    try:
        with open(props_path, 'r', encoding='utf-8') as f:
            for line in f:
                clean_line = line.strip()
                if clean_line.startswith('serverJar='):
                    return clean_line.split('=', 1)[1].strip()
    except Exception as e:
        return None
    return None


def infer_server_type_and_analyze_core_config(db_server: models.Server) -> schemas.ServerCoreConfig:
    server_path = Path(db_server.path)
    mcdr_config_path = server_path / 'config.yml'
    mcdr_config = parse_mcdr_config(mcdr_config_path)
    _, jar_name = parse_start_command(mcdr_config.get("start_command"))
    server_type = mcdr_config.get("handler").replace("_handler", "")
    new_core_config = schemas.ServerCoreConfig(
        server_type=server_type,
        is_fabric=False,
        launcher_jar=jar_name,
        server_jar=jar_name,
        core_version=None,
        loader_version=None
    )
    if server_type == schemas.ServerType.VANILLA:
        fabric_props_path = server_path / 'server' / 'fabric-server-launcher.properties'
        core_jar_name = parse_fabric_launch_properties(fabric_props_path)
        if core_jar_name is not None:
            logger.info(f"Server {db_server.name} was inferred as a fabric server")
            vanilla_version, fabric_loader_version = get_fabric_jar_version(server_path / "server" / jar_name)
            new_core_config.is_fabric = True
            new_core_config.server_jar = core_jar_name
            new_core_config.core_version = vanilla_version
            new_core_config.loader_version = fabric_loader_version
        else:
            logger.info(f"Server {db_server.name} was inferred as a vanilla server")
            vanilla_version = get_vanilla_jar_version(server_path / 'server' / jar_name)
            new_core_config.core_version = vanilla_version
    elif server_type == schemas.ServerType.FORGE:
        logger.info(f"Server {db_server.name} was inferred as a forge server")
        mc_version, forge_loader_version = get_forge_jar_version(server_path / 'server' / jar_name)
        new_core_config.core_version = mc_version
        new_core_config.loader_version = forge_loader_version
    elif server_type == schemas.ServerType.VELOCITY:
        logger.info(f"Server {db_server.name} was inferred as a velocity server")
        new_core_config.core_version = get_velocity_jar_version(server_path / 'server' / jar_name)

    return new_core_config


def get_server_details(server_path: str | Path, server_type: ServerType = 'vanilla'):
    """
    根据服务器路径获取详细信息
    """
    path = Path(server_path)
    details = {
        "port": "N/A",
        "rcon_port": "N/A",
        "rcon_password": "N/A",
    }

    if server_type in ["vanilla", "forge"]:
        properties_file = path / 'server' / 'server.properties'
        if properties_file.exists():
            props = parse_properties(properties_file)
            details["port"] = props.get('server-port', '25565')

            enable_rcon = props.get('enable-rcon', 'false')
            if enable_rcon:
                details["rcon_port"] = props.get('rcon.port', '25575')
                details["rcon_password"] = props.get('rcon.password', '未设置')
                if not details["rcon_password"]:
                    details["rcon_password"] = "未设置"
            else:
                details["rcon_port"] = "未启用RCON"
                details["rcon_password"] = "未启用RCON"

    elif server_type == "velocity":
        velocity_toml_path = path / 'server' / 'velocity.toml'
        if velocity_toml_path.exists():
            v_props = parse_velocity_toml(velocity_toml_path)
            details["port"] = v_props.get('bind', 'N/A').split(':')[-1]
            details["rcon_port"] = "不适用"
            details["rcon_password"] = "不适用"
    return details
