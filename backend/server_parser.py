# server_parser.py

import os
from typing import Dict, Any, Tuple, Optional
from pathlib import Path
from backend import schemas, models
import re
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap
import yaml
import tomli
import tomli_w

from backend.core.utils import get_fabric_jar_version, get_forge_jar_version, get_vanilla_jar_version, get_velocity_jar_version
from backend.logger import logger
from backend.schemas import ServerType


def parse_velocity_toml(file_path: Path) -> Dict[str, Any]:
    if not file_path.exists():
        return {}
    forwarding_secret_path = file_path.parent / "forwarding.secret"
    forwarding_secret = None
    if forwarding_secret_path.exists():
        with open(forwarding_secret_path, "r", encoding='utf-8') as f:
            forwarding_secret = f.read()
    with open(file_path, "rb") as f:
        try:
            data = tomli.load(f)
            servers_config = data.get("servers", {})
            try_order = servers_config.pop("try", [])

            return {
                "bind": data.get("bind", "0.0.0.0:25565"),
                "motd": data.get("motd", ""),
                "online-mode": data.get("online-mode", True),
                "player-info-forwarding-mode": data.get("player-info-forwarding-mode", "none"),
                "servers": servers_config,
                "try": try_order,
                "forwarding_secret": forwarding_secret
            }
        except tomli.TOMLDecodeError:
            return {}


def write_velocity_toml(file_path: Path, config: Dict[str, Any]):
    try:
        with open(file_path, "rb") as f:
            toml_data = tomli.load(f)
    except (FileNotFoundError, tomli.TOMLDecodeError):
        toml_data = {}
    forwarding_secret_path = file_path.parent / "forwarding.secret"
    toml_data['bind'] = config.get('bind', toml_data.get('bind', '0.0.0.0:25565'))
    toml_data['motd'] = config.get('motd', toml_data.get('motd', '<#09add3>A Velocity Server'))
    toml_data['online-mode'] = config.get('online-mode', toml_data.get('online-mode', True))
    toml_data['player-info-forwarding-mode'] = config.get(
        'player-info-forwarding-mode', toml_data.get('player-info-forwarding-mode', 'none')
    )
    if 'servers' not in toml_data or not isinstance(toml_data.get('servers'), dict):
        toml_data['servers'] = {}
    new_servers = config.get('servers', {})
    new_try_order = config.get('try', [])
    current_server_keys = list(parse_velocity_toml(file_path).get('servers', {}).keys())
    for key in current_server_keys:
        if key in toml_data['servers']:
            del toml_data['servers'][key]
    toml_data['servers'].update(new_servers)
    toml_data['servers']['try'] = new_try_order
    toml_data['forced-hosts'] = {}
    file_path.parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, "wb") as f:
        tomli_w.dump(toml_data, f)
    if (secret := config.get("forwarding_secret", None)) is not None:
        with open(forwarding_secret_path, "w", encoding='utf-8') as f:
            f.write(str(secret))


def parse_properties(file_path):
    """解析 Java .properties 文件"""
    props = {}
    if not os.path.exists(file_path):
        return props
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    key_value = line.split('=', 1)
                    if len(key_value) == 2:
                        value = key_value[1].strip()
                        props[key_value[0].strip()] = key_value[1].strip()
                        if value.lower() == 'true':
                            value = True
                        elif value.lower() == 'false':
                            value = False
                        elif value.isdigit():
                            value = int(value)
                        props[key_value[0].strip()] = value
    except Exception:
        # 文件可能存在编码问题等，忽略错误
        pass
    return props


def write_properties_file(path: Path, props: Dict[str, Any]):
    """将字典写入 .properties 文件"""
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write("# Minecraft server properties\n")
        f.write("# Generated by AS-Panel\n")
        for key, value in props.items():
            f.write(f"{key}={str(value).lower() if isinstance(value, bool) else value}\n")


def parse_jvm_args(args_str: str) -> schemas.ServerConfigJvm:
    """从 jvm_args 字符串中解析出内存和额外参数"""
    min_mem_match = re.search(r'-Xms(\S+)', args_str)
    max_mem_match = re.search(r'-Xmx(\S+)', args_str)

    min_mem = min_mem_match.group(1) if min_mem_match else "1G"
    max_mem = max_mem_match.group(1) if max_mem_match else "4G"
    # 移除内存参数以获取额外参数
    extra_args = args_str.replace(min_mem_match.group(0), '') if min_mem_match else args_str
    extra_args = extra_args.replace(max_mem_match.group(0), '') if max_mem_match else extra_args

    return schemas.ServerConfigJvm(
        min_memory=min_mem,
        max_memory=max_mem,
        extra_args=extra_args.strip()
    )


def parse_start_command(command_str: str) -> Tuple[schemas.ServerConfigJvm, str]:
    if not command_str:
        return schemas.ServerConfigJvm(min_memory="1G", max_memory="4G", extra_args=""), "server.jar"
    parts = command_str.split()
    try:
        jar_index = parts.index('-jar')
        jar_name = parts[jar_index + 1]
        jvm_args_list = parts[1:jar_index]
        jvm_config = parse_jvm_args(' '.join(jvm_args_list))
        return jvm_config, jar_name
    except (ValueError, IndexError):
        jvm_config = parse_jvm_args(' '.join(parts[1:]))
        return jvm_config, "server.jar"


def parse_mcdr_config(file_path: Path) -> Dict:
    with file_path.open('r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    return config if isinstance(config, dict) else {}


def _deep_update(source: Dict, overrides: Dict) -> Dict:
    for key, value in overrides.items():
        if isinstance(value, dict) and key in source and isinstance(source.get(key), dict):
            source[key] = _deep_update(source[key], value)
        else:
            source[key] = value
    return source


def _convert_to_dict(data: Any) -> Any:
    if isinstance(data, CommentedMap):
        return {key: _convert_to_dict(value) for key, value in data.items()}
    if isinstance(data, list):
        return [_convert_to_dict(element) for element in data]
    return data


def write_mcdr_config(file_path: Path, config: Dict) -> Dict:
    yaml_rt = YAML()
    yaml_rt.indent(mapping=2, sequence=4, offset=2)
    yaml_rt.preserve_quotes = True
    if file_path.is_file():
        with file_path.open('r', encoding='utf-8') as f:
            data = yaml_rt.load(f)
    else:
        data = CommentedMap()
    updated_data = _deep_update(data, config)
    with file_path.open('w', encoding='utf-8') as f:
        yaml_rt.dump(updated_data, f)
    return _convert_to_dict(updated_data)


def parse_fabric_launch_properties(props_path: Path) -> Optional[str]:
    if not props_path.is_file():
        return None
    try:
        with open(props_path, 'r', encoding='utf-8') as f:
            for line in f:
                clean_line = line.strip()
                if clean_line.startswith('serverJar='):
                    return clean_line.split('=', 1)[1].strip()
    except Exception as e:
        return None
    return None


def infer_server_type_and_analyze_core_config(db_server: models.Server) -> schemas.ServerCoreConfig:
    server_path = Path(db_server.path)
    mcdr_config_path = server_path / 'config.yml'
    mcdr_config = parse_mcdr_config(mcdr_config_path)
    _, jar_name = parse_start_command(mcdr_config.get("start_command"))
    server_type = mcdr_config.get("handler").replace("_handler", "")
    new_core_config = schemas.ServerCoreConfig(
        server_type=server_type,
        is_fabric=False,
        launcher_jar=jar_name,
        server_jar=jar_name,
        core_version=None,
        loader_version=None
    )
    if server_type == schemas.ServerType.VANILLA:
        fabric_props_path = server_path / 'server' / 'fabric-server-launcher.properties'
        core_jar_name = parse_fabric_launch_properties(fabric_props_path)
        if core_jar_name is not None:
            logger.info(f"Server {db_server.name} was inferred as a fabric server")
            vanilla_version, fabric_loader_version = get_fabric_jar_version(server_path / "server" / jar_name)
            new_core_config.is_fabric = True
            new_core_config.server_jar = core_jar_name
            new_core_config.core_version = vanilla_version
            new_core_config.loader_version = fabric_loader_version
        else:
            logger.info(f"Server {db_server.name} was inferred as a vanilla server")
            vanilla_version = get_vanilla_jar_version(server_path / 'server' / jar_name)
            new_core_config.core_version = vanilla_version
    elif server_type == schemas.ServerType.FORGE:
        logger.info(f"Server {db_server.name} was inferred as a forge server")
        mc_version, forge_loader_version = get_forge_jar_version(server_path / 'server' / jar_name)
        new_core_config.core_version = mc_version
        new_core_config.loader_version = forge_loader_version
    elif server_type == schemas.ServerType.VELOCITY:
        logger.info(f"Server {db_server.name} was inferred as a velocity server")
        new_core_config.core_version = get_velocity_jar_version(server_path / 'server' / jar_name)

    return new_core_config


def get_server_details(server_path: str | Path, server_type: ServerType = 'vanilla'):
    """
    根据服务器路径获取详细信息
    """
    path = Path(server_path)
    details = {
        "port": "N/A",
        "rcon_port": "N/A",
        "rcon_password": "N/A",
    }

    if server_type in ["vanilla", "forge"]:
        properties_file = path / 'server' / 'server.properties'
        if properties_file.exists():
            props = parse_properties(properties_file)
            details["port"] = props.get('server-port', '25565')

            enable_rcon = props.get('enable-rcon', 'false')
            if enable_rcon:
                details["rcon_port"] = props.get('rcon.port', '25575')
                details["rcon_password"] = props.get('rcon.password', '未设置')
                if not details["rcon_password"]:
                    details["rcon_password"] = "未设置"
            else:
                details["rcon_port"] = "未启用RCON"
                details["rcon_password"] = "未启用RCON"

    elif server_type == "velocity":
        velocity_toml_path = path / 'server' / 'velocity.toml'
        if velocity_toml_path.exists():
            v_props = parse_velocity_toml(velocity_toml_path)
            details["port"] = v_props.get('bind', 'N/A').split(':')[-1]
            details["rcon_port"] = "不适用"
            details["rcon_password"] = "不适用"
    return details
